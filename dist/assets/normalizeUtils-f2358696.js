import{s as T,b as F,a as _}from"./Error-e5869661.js";import{t as B,r as E}from"./typedArrayUtil-6bfe4dae.js";import{m as $,v as J}from"./Polyline-7684a66d.js";import{k as N,d as W,R as I,j as H}from"./Extent-b8913cd1.js";import{y as K,c as z,v as Q}from"./jsonUtils-eb956695.js";import"./geometry-1b3a0099.js";import{U as C,j as V}from"./request-c6faf466.js";import{f as Y,r as Z,o as tt}from"./utils-a49efee8.js";const U={102100:{maxX:20037508342788905e-9,minX:-20037508342788905e-9,plus180Line:new $({paths:[[[20037508342788905e-9,-20037508342788905e-9],[20037508342788905e-9,20037508342788905e-9]]],spatialReference:N.WebMercator}),minus180Line:new $({paths:[[[-20037508342788905e-9,-20037508342788905e-9],[-20037508342788905e-9,20037508342788905e-9]]],spatialReference:N.WebMercator})},4326:{maxX:180,minX:-180,plus180Line:new $({paths:[[[180,-180],[180,180]]],spatialReference:N.WGS84}),minus180Line:new $({paths:[[[-180,-180],[-180,180]]],spatialReference:N.WGS84})}};function L(t,s){return Math.ceil((t-s)/(2*s))}function D(t,s){const f=X(t);for(const n of f)for(const e of n)e[0]+=s;return t}function X(t){return K(t)?t.rings:t.paths}async function et(t,s,f,n){const e=Y(t),c=s[0].spatialReference,a={...n,query:{...e.query,f:"json",sr:JSON.stringify(c),target:JSON.stringify({geometryType:z(s[0]),geometries:s}),cutter:JSON.stringify(f)}},o=await C(e.path+"/cut",a),{cutIndexes:p,geometries:g=[]}=o.data;return{cutIndexes:p,geometries:g.map(h=>{const x=Q(h);return x.spatialReference=c,x})}}async function st(t,s,f){const n=typeof t=="string"?V(t):t,e=s[0].spatialReference,c=z(s[0]),a={...f,query:{...n.query,f:"json",sr:e.wkid?e.wkid:JSON.stringify(e),geometries:JSON.stringify(Z(s))}},{data:o}=await C(n.path+"/simplify",a);return tt(o.geometries,c,e)}const G=T.getLogger("esri.geometry.support.normalizeUtils");function nt(t){return t.type==="polygon"}function ot(t){return t[0].type==="polygon"}function rt(t){return t[0].type==="polyline"}function it(t,s){if(!(t instanceof $||t instanceof J)){const e="straightLineDensify: the input geometry is neither polyline nor polygon";throw G.error(e),new _(e)}const f=X(t),n=[];for(const e of f){const c=[];n.push(c),c.push([e[0][0],e[0][1]]);for(let a=0;a<e.length-1;a++){const o=e[a][0],p=e[a][1],g=e[a+1][0],h=e[a+1][1],x=Math.sqrt((g-o)*(g-o)+(h-p)*(h-p)),l=(h-p)/x,y=(g-o)/x,u=x/s;if(u>1){for(let M=1;M<=u-1;M++){const S=M*s,r=y*S+o,i=l*S+p;c.push([r,i])}const R=(x+Math.floor(u-1)*s)/2,b=y*R+o,k=l*R+p;c.push([b,k])}c.push([g,h])}}return nt(t)?new J({rings:n,spatialReference:t.spatialReference}):new $({paths:n,spatialReference:t.spatialReference})}function O(t,s,f){if(s){const n=it(t,1e6);t=H(n,!0)}return f&&(t=D(t,f)),t}function P(t,s,f){if(Array.isArray(t)){const n=t[0];if(n>s){const e=L(n,s);t[0]=n+e*(-2*s)}else if(n<f){const e=L(n,f);t[0]=n+e*(-2*f)}}else{const n=t.x;if(n>s){const e=L(n,s);t=t.clone().offset(e*(-2*s),0)}else if(n<f){const e=L(n,f);t=t.clone().offset(e*(-2*f),0)}}return t}function ft(t,s){let f=-1;for(let n=0;n<s.cutIndexes.length;n++){const e=s.cutIndexes[n],c=s.geometries[n],a=X(c);for(let o=0;o<a.length;o++){const p=a[o];p.some(g=>{if(g[0]<180)return!0;{let h=0;for(let l=0;l<p.length;l++){const y=p[l][0];h=y>h?y:h}h=Number(h.toFixed(9));const x=-360*L(h,180);for(let l=0;l<p.length;l++){const y=c.getPoint(o,l);c.setPoint(o,l,y.clone().offset(x,0))}return!0}})}if(e===f){if(ot(t))for(const o of X(c))t[e]=t[e].addRing(o);else if(rt(t))for(const o of X(c))t[e]=t[e].addPath(o)}else f=e,t[e]=c}return t}async function ct(t,s,f){if(!Array.isArray(t))return ct([t],s);s&&typeof s!="string"&&G.warn("normalizeCentralMeridian()","The url object is deprecated, use the url string instead");const n=typeof s=="string"?s:(s==null?void 0:s.url)??F.geometryServiceUrl;let e,c,a,o,p,g,h,x,l=0;const y=[],u=[];for(const r of t)if(B(r))u.push(r);else if(e||(e=r.spatialReference,c=W(e),a=e.isWebMercator,g=a?102100:4326,o=U[g].maxX,p=U[g].minX,h=U[g].plus180Line,x=U[g].minus180Line),c)if(r.type==="mesh")u.push(r);else if(r.type==="point")u.push(P(r.clone(),o,p));else if(r.type==="multipoint"){const i=r.clone();i.points=i.points.map(m=>P(m,o,p)),u.push(i)}else if(r.type==="extent"){const i=r.clone()._normalize(!1,!1,c);u.push(i.rings?new J(i):i)}else if(r.extent){const i=r.extent,m=L(i.xmin,p)*(2*o);let d=m===0?r.clone():D(r.clone(),m);i.offset(m,0),i.intersects(h)&&i.xmax!==o?(l=i.xmax>l?i.xmax:l,d=O(d,a),y.push(d),u.push("cut")):i.intersects(x)&&i.xmin!==p?(l=i.xmax*(2*o)>l?i.xmax*(2*o):l,d=O(d,a,360),y.push(d),u.push("cut")):u.push(d)}else u.push(r.clone());else u.push(r);let R=L(l,o),b=-90;const k=R,M=new $;for(;R>0;){const r=360*R-180;M.addPath([[r,b],[r,-1*b]]),b*=-1,R--}if(y.length>0&&k>0){const r=ft(y,await et(n,y,M,f)),i=[],m=[];for(let w=0;w<u.length;w++){const j=u[w];if(j!=="cut")m.push(j);else{const q=r.shift(),v=t[w];E(v)&&v.type==="polygon"&&v.rings&&v.rings.length>1&&q.rings.length>=v.rings.length?(i.push(q),m.push("simplify")):m.push(a?I(q):q)}}if(!i.length)return m;const d=await st(n,i,f),A=[];for(let w=0;w<m.length;w++){const j=m[w];j!=="simplify"?A.push(j):A.push(a?I(d.shift()):d.shift())}return A}const S=[];for(let r=0;r<u.length;r++){const i=u[r];if(i!=="cut")S.push(i);else{const m=y.shift();S.push(a===!0?I(m):m)}}return S}function xt(t,s){const f=W(s);if(f){const[n,e]=f.valid,c=e-n;if(t<n)for(;t<n;)t+=c;if(t>e)for(;t>e;)t-=c}return t}export{xt as U,L as i,U as r,D as s,ct as v};
